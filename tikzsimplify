#!/usr/bin/env python3

from __future__ import print_function #Use python3 print statments in python2.7
import re
from heapq import *
from functools import total_ordering
import sys
from math import log10,pow

tikzpic = re.compile(r'\\begin{tikzpicture}(.*)\end{tikzpicture}',re.MULTILINE|re.DOTALL)
axis = re.compile(r'\\begin{axis}\s*?(\[.*?\])?(.*?)\\end{axis}',re.MULTILINE|re.DOTALL)
plot= re.compile(r'\\addplot\s*?(\[.*?\])?\s*?table\s*?(\[.*?\])?\s*?{(.*?)};',re.MULTILINE|re.DOTALL)
comments = re.compile(r'%.*?$.?',re.MULTILINE|re.DOTALL)

#Match plots of the same style that lead on from each other.
#matlab2tikz sometimes creates these and I don't know why
lead_on_plots = re.compile(r'''( \\addplot \s* (\[.*?\]) \s*
                                   table \s*? (\[.*?\]) \s* { % \s*
                                       (.*?)
                                       ^(.*?)$) \s*};
                              \s*  \\addplot .*? \2 .*? \5
                            ''',re.X|re.MULTILINE|re.DOTALL)

@total_ordering
class Point:
    #Doubly linked list of coordinates

    def __init__(self,x,y=None,p=None,n=None):
        self.x = x 
        self.y = y
        self.n = n
        self.p = p
        if p:
            p.n = self
        if n:
            n.p = self

    def area(self):
        if self.n is None or self.p is None:
            return None

        a = self.p
        b = self
        c = self.n
        ax,bx,cx = a.x,b.x,c.x
        ay,by,cy = a.y,b.y,c.y

        # ar = abs((b.y - c.y)*a.x + (c.y-a.y)*b.x + (a.y-b.y)*c.x)/2
        ar = abs((by - cy)*ax + (cy-ay)*bx + (ay-by)*cx)/2

        return ar

    def __lt__(self,other):
        return self.area() < other.area()

    def __eq__(self,other):
        return self.area() == other.area()

    def __str__(self):
        return '\t%0.6f\t%0.6f' % (self.x,self.y)


    def simplify(self,tol):
        '''
         Perform the Visvalingam--Whyatt algorithm to simplify the path.
         Points are added to a min-heap where the value associated is the 
         area of the triangle made with its two neighbouring points. Points
         are then removed from the list, minimum first, until the smallest
         area is larger than 'tol'.
        
         The first and last points are skipped.
        '''

        h = []
        pt = self.n
        while pt.n:
            heappush(h,pt)
            pt = pt.n

        i = 0
        while len(h) > 0 and h[0].area() < tol:
            i += 1
            pt = heappop(h)
            pt.p.n = pt.n
            pt.n.p = pt.p

        print("%d points removed"%i,file=sys.stderr)

def table_to_path(s,logx=False,logy=False):
    rows = s.split('\n')
    head = None
    tail = None

    i = 1
    for row in rows:
        if row:
            x,y = row.split()
            if x == 'nan' or y == 'nan\\\\':
                continue
            x,y = float(x),float(y.strip('\\'))

            if logx:
                x = log10(x)
            if logy:
                y = log10(y)
            tail = Point(x,y,tail)
            if i ==1:
                head = tail
            i += 1
    print("%d points found"%i,file=sys.stderr)

    return head

def path_to_table(head,logx=False,logy=False):
    '''
    Render points in the path to table format
    '''
    pathlist=[]
    pt = head
    while pt:
        x,y = pt.x,pt.y
        if logx:
            x = pow(10,x)
        if logy:
            y = pow(10,y)
        pathlist.append('\t%0.6g\t%0.6g\\\\' % (x,y))
        pt = pt.n
    return '\n'.join(pathlist)

def simplify_plot(match):
    opts = match.group(1)

    logx= False
    xmode = re.search('xmode=(.*?),',opts)
    if xmode and xmode.group(1) == 'log':
        print("using logx mode",file=sys.stderr)
        logx=True
    
    logy= False
    ymode = re.search('ymode=(.*?),',opts)
    if ymode and ymode.group(1) == 'log':
        print("using logy mode",file=sys.stderr)
        logy=True

    xmin = float(re.search('xmin=(.*?),',opts).group(1))
    xmax = float(re.search('xmax=(.*?),',opts).group(1))
    if logx:
        xmin,xmax = log10(xmin),log10(xmax)

    ymin = float(re.search('ymin=(.*?),',opts).group(1))
    ymax = float(re.search('ymax=(.*?),',opts).group(1))
    if logy:
        ymin,ymax = log10(ymin),log10(ymax)

    if tol is None:
        tab_tol = (xmax-xmin)*(ymax-ymin)/(15*9*500)
        print("selecting tol of: %g"%tab_tol,file=sys.stderr)
    else:
        tab_tol = tol
    
    def simplify_table(match):
        path = table_to_path(comments.sub('',match.group(3)),logx,logy)
        path.simplify(tab_tol)
        return '\\addplot %s\n  table%s{%%\n%s\n};' % ( match.group(1) or '', match.group(2) or '', path_to_table(path,logx,logy))


    return  '\\begin{axis}%s\n%s\n\\end{axis}'%( match.group(1) or '', plot.sub(simplify_table,match.group(2)) or '')


tol = None
f = open(sys.argv[1],'rU')
if len(sys.argv) > 2:
    tol = float(sys.argv[2])
else:
    tol = None

s = f.read()
s = axis.sub(simplify_plot,s)
s,n = lead_on_plots.subn(r'\1',s)
if n>0:
    print("Merged lead-on plots, simplifying again...",file=sys.stderr)
    s = axis.sub(simplify_plot,s)

print(s)
