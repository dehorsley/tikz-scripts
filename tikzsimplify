#!/usr/bin/env python3

from __future__ import print_function #Use python3 print statments in python2.7
import re
from heapq import *
from functools import total_ordering
import sys

tikzpic = re.compile(r'\\begin{tikzpicture}(.*)\end{tikzpicture}',re.MULTILINE|re.DOTALL)
axis = re.compile(r'\\begin{axis}\s*?(\[.*?\])?(.*?)\\end{axis}',re.MULTILINE|re.DOTALL)
plot= re.compile(r'\\addplot\s*?(\[.*?\])?\s*?table\s*?(\[.*?\])?\s*?{(.*?)};',re.MULTILINE|re.DOTALL)
comments = re.compile(r'%.*?$.?',re.MULTILINE|re.DOTALL)

#Match plots of the same style that lead on from each other.
#matlab2tikz sometimes creates these and I don't know why
lead_on_plots = re.compile(r'''( \\addplot \s* (\[.*?\]) \s*
                                   table \s*? (\[.*?\]) \s* { % \s*
                                       (.*?)
                                       ^(.*?)$) \s*};
                              \s*  \\addplot .* \2 .*? \5
                            ''',re.X|re.MULTILINE|re.DOTALL)
@total_ordering
class Point:
    #Doubly linked list of coordinates

    def __init__(self,x,y=None,p=None,n=None):
        #If we're given a y value, assume x and y are coordinates of a point,
        #otherwise assume x is the string of a path in table format.

        if y:
            self.x = x
            self.y = y
            self.n = n
            self.p = p

            if p:
                p.n = self
            if n:
                n.p = self
        else:
            rows = x.split('\n')
            
            row = rows.pop(0)
            x,y = row.split()
            x,y = float(x),float(y.strip('\\'))
            self.x = x
            self.y = y
            i = 1

            pt = self
            for row in rows:
                if row:
                    x,y = row.split()
                    if x == 'nan' or y == 'nan\\\\':
                        continue
                    x,y = float(x),float(y.strip('\\'))
                    pt = Point(x,y,pt)
                    i += 1
            print("%d points found"%i,file=sys.stderr)
            


    def area(self):
        if self.n is None or self.p is None:
            return None

        a = self.p
        b = self
        c = self.n

        ar = abs((b.y - c.y)*a.x + (c.y-a.y)*b.x + (a.y-b.y)*c.x)/2

        return ar

    def __lt__(self,other):
        return self.area() < other.area()

    def __eq__(self,other):
        return self.area() == other.area()

    def __str__(self):
        return '\t%0.6f\t%0.6f' % (self.x,self.y)

    def render(self):
        '''
        Render the remaining points in the path to table format
        '''
        pathlist=[]
        pt = self
        while pt:
            pathlist.append('\t%0.6f\t%0.6f\\\\' % (pt.x,pt.y))
            pt = pt.n
        return '\n'.join(pathlist)

    def simplify(self,tol):
        '''
         Perform the Visvalingam--Whyatt algorithm to simplify the path.
         Points are added to a min-heap where the value associated is the 
         area of the triangle made with its two neighbouring points. Points
         are then removed from the list, minimum first, until the smallest
         area is larger than 'tol'.
        
         The first and last points are skipped.
        '''

        h = []
        pt = self.n
        while pt.n:
            heappush(h,pt)
            pt = pt.n

        i = 0
        while len(h) > 0 and h[0].area() < tol:
            i += 1
            pt = heappop(h)
            pt.p.n = pt.n
            pt.n.p = pt.p

        print("%d points removed"%i,file=sys.stderr)


def simplify_plot(match):
    opts = match.group(1)
    xmin = float(re.search('xmin=(.*?),',opts).group(1))
    xmax = float(re.search('xmax=(.*?),',opts).group(1))
    ymin = float(re.search('ymin=(.*?),',opts).group(1))
    ymax = float(re.search('ymax=(.*?),',opts).group(1))
    if tol is None:
        tab_tol = (xmax-xmin)*(ymax-ymin)/(15*9*400)
        print("selecting tol of: %g"%tab_tol,file=sys.stderr)
    else:
        tab_tol = tol
    
    def simplify_table(match):
        path = Point(comments.sub('',match.group(3)))
        path.simplify(tab_tol)
        return '\\addplot %s\n  table%s{%%\n%s\n};' % ( match.group(1) or '', match.group(2) or '', path.render())

    return  '\\begin{axis}%s\n%s\n\\end{axis}'%( match.group(1) or '', plot.sub(simplify_table,match.group(2)) or '')


tol = None
f = open(sys.argv[1],'rU')
if len(sys.argv) > 2:
    tol = float(sys.argv[2])
else:
    tol = None

s = f.read()
s,n = lead_on_plots.subn(r'\1',s)
print("merged %d lead on plots"%n,file=sys.stderr)
s = axis.sub(simplify_plot,s)
print(s)
